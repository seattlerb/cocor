require 'BitSet'

class Token
  attr_accessor :kind, :pos, :col, :line, :val
end

class Buffer

  # TODO: switch these to instance variables and clean this shit up
  @@buf = ""
  @@bufLen = 0
  @@pos = 0
  
  def self.Fill(name)
    @@buf = File.new(name).readlines.join('')
    @@bufLen = @@buf.size
  end
  
  def self.Set(position)
    if (position < 0) then
      position = 0
    elsif (position >= @@bufLen) then
      position = @@bufLen
    end
    @@pos = position
  end
  
  def self.read
    if (@@pos < @@bufLen) then
      c = @@buf[@@pos]
      @@pos += 1
      return c
    else
      return 65535				# FIX!!!
    end
  end
end

class Scanner

  @@err = nil					# error messages

  EOF = -1
  EOL = '\r'[0]
  MAXASCII = 127				# FIX: this is dumb
  MAXCHR = '\uffff'				# FIX: not ruby compatible
  SPACE = ' '[0]

-->declarations

  # TODO: make fucking sure these become instance vars
  private
  @@t=Token.new			# current token
  @@ch=nil			# current input character
  @@pos=0			# position of current character
  @@line=0			# line number of current character
  @@lineStart=0			# start position of current line
  @@oldEols=0			# >0: no. of EOL in a comment
  @@ignore=BitSet.new(128)	# set of characters to be ignored by the scanner

  def self.err()		# HACK: added because @@err was accessed from Parser.rb
    @@err
  end

  def self.Init(file, e=ErrorStream.new)
    @@ignore = BitSet.new(128)
-->initialization
    @@err = e
    Buffer.Fill(file)
    @@pos = -1
    @@line = 1
    @@lineStart = 0
    @@oldEols = 0
    self.NextCh
  end
	
  def self.NextCh
    if (@@oldEols > 0) then
      @@ch = EOL
      @@oldEols -= 1
    else
      @@ch = Buffer.read
      @@pos
      if (@@ch==EOL) then
	@@line += 1
	@@lineStart = @@pos + 1
      end
    end
    if (@@ch > MAXASCII) then
      if (@@ch == MAXCHR) then
	@@ch = EOF
      else
	$stderr.println("-- invalid character at line " + @@line + " col " + (@@pos - @@lineStart))
	@@ch = SPACE
      end
    end
  end
	
-->comment
	
  def self.CheckLiteral
    case (@@t.val[0])
-->literals
    end
  end

  def self.Scan
    buf=""
    self.NextCh while @@ignore.get(@@ch)
-->scan1
    @@t = Token.new
    @@t.pos = @@pos
    @@t.col = @@pos - @@lineStart
    @@t.line = @@line 
    @@t.kind = "FIX"
    buf = ""
    state = @@start[@@ch]
    apx = 0

    while true
      buf += @@ch.chr
      self.NextCh
      $stderr.puts "state = #{state}, ch = #{@@ch} / '#{@@ch.chr}'"
      case state
      when 0				# NextCh already done
	@@t.kind = @@noSym
	break				# TODO: make sure this breaks the while, not the case
-->scan2
      end
    end
    @@t.val = buf.to_s

    raise "kind not set for Token" unless @@t.kind and @@t.kind != "FIX"

    return @@t
  end
end

$$$
