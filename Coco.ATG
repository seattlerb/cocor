/*$01267*/
/* Coco/R
   This grammar produces LL1 warnings for Attribs and AttrDecl, which can be ignored.
*/
COMPILER Coco

	private; @@ident = 0
	private; @@string = 1
	private; @@genScanner = nil

	private; def Parser.SemErr(n)
		Scanner.err.SemErr(n, @t.line, @t.col)
	end
	
	private; def Parser.MatchLiteral(sp) # store string either as token or as literal
		sym = Tab.Sym(sp)
		matchedSp = DFA.MatchedDFA(sym.name, sp)
		if (matchedSp==Tab::NoSym)
		  sym.struct = Tab::ClassToken
		else 
		  sym1 = Tab.Sym(matchedSp)
		  sym1.struct = Tab::ClassLitToken
		  sym.struct = Tab::LitToken
		end
	end
	
	private; def Parser.SetCtx(p) # set transition code to contextTrans
		while (p > 0)
			n = Tab.Node(p)
			if (n.typ==Tab::Chr || n.typ==Tab::Clas) then
				n.p2 = Tab::ContextTrans
			elsif (n.typ==Tab::Opt || n.typ==Tab::Iter) then
				SetCtx(n.p1)
			elsif (n.typ==Tab::Alt) then
				SetCtx(n.p1)
				SetCtx(n.p2)
			end
			p = n.next
		end
	end
	
	private; def Parser.SetDDT(s)
		for i in 1..(s.length-1)
		  ch = s[i].chr
		  if (/[0-9]/.match(ch)) then
		    Tab.ddt[ch[0]] = true
		  end
		end
	end
	
	private; def Parser.FixString(s)
		a=s # TODO: remove a
		len = a.length
		if (len == 2) then
		  SemErr(29)
		end
		dbl = false
		for i in 1..(len-1)
		  if (a[i]=='"') then
		    dbl = true
		  elsif (a[i]==' ') then
		    SemErr(24)
		  end
		end
		if (!dbl) then
		  a[0] = '"'
		  a[len-1] = '"'
		end

		return a.clone
	end
	
# -------------------------------------------------------------------------

CHARACTERS
  letter   = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit    = "0123456789".
  eol      = CHR(13) + CHR(10).
  tab      = CHR(9).
  noQuote1 = ANY - '"' - eol.
  noQuote2 = ANY - "'" - eol.

IGNORE eol + tab


TOKENS
  ident     = letter {letter | digit}.
  string    = '"' {noQuote1} '"' | "'" {noQuote2} "'".
  number    = digit {digit}.
  badString = '"' {noQuote1} eol | "'" {noQuote2} eol.


PRAGMAS
  ddtSym   = "$" {digit}.	(. SetDDT(@t.val) .)


COMMENTS FROM "/*" TO "*/" NESTED

/* ------------------------------------------------------------------------- */

PRODUCTIONS

Coco                            (. gramLine = sp = eofSy = 0
                                   undefined = noAttrs = noRet = ok = ok1 = false
                                   gramName = ""
                                   sym = nil
                                   g = nil
				.)
=
  "COMPILER"                    (. gramLine = @token.line
                                   eofSy = Tab.NewSym(Tab::T, "EOF", 0)
                                   @@genScanner = true
                                   ok = true
                                   Tab.ignored = BitSet.new()
				.) 
  ident                         (. gramName = @token.val
                                   Tab.semDeclPos = Position.new()
                                   Tab.semDeclPos.beg = @t.pos
				.)
  {ANY}                         (. Tab.semDeclPos.len = @t.pos - Tab.semDeclPos.beg
                                   Tab.semDeclPos.col = 0
				.)
  { Declaration }
                                SYNC 
  "PRODUCTIONS"                 (. Tab.ignored.set(32)	#' ' is always ignored
                                   if (@@genScanner) then
				        Tab.PrintGraph
					ok = DFA.MakeDeterministic()
				   end
                                   Tab.nNodes = 0
				.)
  { ident                       (. sp = Tab.FindSym(@token.val)
                                   undefined = sp == Tab::NoSym
                                   if (undefined) then
                                       sp = Tab.NewSym(Tab::Nt, @token.val, @token.line)
                                       sym = Tab.Sym(sp)
                                   else 
                                       sym = Tab.Sym(sp)
                                       if (sym.typ==Tab::Nt) then
                                           if (sym.struct > 0) then
						SemErr(7)
					   end
                                       else
					 SemErr(8)
                                         sym.line = @token.line
				       end
                                   end
                                   noAttrs = sym.attrPos.nil?
				   sym.attrPos = nil
                                   noRet = sym.retVar.nil? || sym.retVar.empty?
				   sym.retVar = nil
				.)
    [ AttrDecl <sym> ]          (. if (!undefined) then
                                     if ((noAttrs  && !sym.attrPos.nil?) || 
				         (noRet    && !sym.retVar.nil?) || 
					 (!noAttrs && sym.attrPos.nil?) || 
					 (!noRet   && sym.retVar .nil?)) then
				       SemErr(5)
				     end
				   end
                                   .)
    [ SemText <^sym.semPos> ] 
    WEAK "="
    Expression <^g>             (. sym.struct = g.l
                                   Tab.CompleteGraph(g.r)
				.) 
    WEAK "."
  }                             (. if (Tab.ddt[2]) then
				     Tab.PrintGraph()
				   end
                                   Tab.gramSy = Tab.FindSym(gramName)
                                   if (Tab.gramSy==Tab::NoSym) then
				       SemErr(11)
                                   else
                                       sym = Tab.Sym(Tab.gramSy)
                                       unless (sym.attrPos.nil?) then
				         SemErr(12)
				       end
                                   end
				.)
  "END" ident                   (. if (!gramName == @token.val) then
					 SemErr(17)
				   end
                                   if (Scanner.err.count == 0) then
                                       puts("checking")
                                       Tab.CompSymbolSets()
                                       if (ok) then
					 ok = Tab.NtsComplete()
				       end
                                       if (ok) then
                                           ok1 = Tab.AllNtReached()
                                           ok = Tab.NoCircularProductions()
                                       end
                                       if (ok) then
					 ok = Tab.AllNtToTerm()
				       end
                                       if (ok) then
					 ok1 = Tab.LL1()
				       end
                                       if (Tab.ddt[7]) then
					 Tab.XRef()
				       end
                                       if (ok) then
                                           puts("parser")
					   $stdout.flush()
                                           ParserGen.WriteParser()
                                           if (@@genScanner) then
                                               puts(" + scanner")
                                               $stdout.flush()
                                               ok = DFA.WriteScanner()
                                               if (Tab.ddt[0]) then
					         DFA.PrintStates()
					       end
                                           end
                                           puts(" generated")
                                           if (Tab.ddt[8]) then
					     ParserGen.WriteStatistics()
					   end
                                       end
                                   else
				     ok = false
				   end
                                   if (Tab.ddt[6]) then
					Tab.PrintSymbolTable()
				   end
                                   puts
				.)
  ".".
/*------------------------------------------------------------------------------------*/
Declaration                     (. g1 = g2 = nil
				   nested = false
				.)
=
  "CHARACTERS" { SetDecl }
| "TOKENS"     { TokenDecl <Tab::T> }
| "PRAGMAS"    { TokenDecl <Tab::Pr> }
| "COMMENTS"
  "FROM" TokenExpr <^g1>
  "TO" TokenExpr <^g2>
  ( "NESTED"                    (. nested = true .)
  |                             (. nested = false .)
  )                             (. Comment.new(g1.l, g2.l, nested) .)
| "IGNORE" Set <^Tab.ignored>
.

/*------------------------------------------------------------------------------------*/
SetDecl                         (. c = 0
				   s = nil
				   name = ""
				.)
=
  ident                         (. name = @token.val
                                   c = Tab.ClassWithName(name)
                                   if (c > 0) then
				     SemErr(7)
				   end
				.)
  "=" Set <^s>                  (. c = Tab.NewClass(name, s) .)
  ".".
/*------------------------------------------------------------------------------------*/
Set <^BitSet s>                 (. s2 = nil .)
=
  SimSet <^s>
  { "+" SimSet <^s2>            (. s.or(s2) .)
  | "-" SimSet <^s2>            (. Sets.Differ(s, s2) .)
  }.
/*------------------------------------------------------------------------------------*/
SimSet <^BitSet s>              (. name = ""
				   c = n = 0
				.)
=
                                (. s = BitSet.new(128) .)
( ident                         (. c = Tab.ClassWithName(@token.val)
                                   if (c < 0) then
				     SemErr(15)
				   else
				     s.or(Tab.Class(c))
				   end
				.)
| string                        (. name = @token.val
				   i=1
                                   while (name[i] != name[0]) do
                                     s.set(name[i])
				     i += 1
				   end
				.)
| "CHR" "(" number              (. n = @token.val.to_i
                                   s.set(n)
				.)
  ")"
| "ANY"                         (. s = Sets.FullSet(127) .)
)
.
/*------------------------------------------------------------------------------------*/
TokenDecl <int typ>             (. s = pos = g = nil
				   sp = 0
				 .)
=
  Symbol <^s>                   (. if (Tab.FindSym(s.name) != Tab::NoSym) then
				     SemErr(7)
				     sp = 0
                                   else
                                     sp = Tab.NewSym(typ, s.name, @token.line)
                                     Tab.Sym(sp).struct = Tab::ClassToken
                                   end
				   puts "## symbol = #{s.name}"
				 .)
  SYNC
  ( "=" TokenExpr <^g> "."      (. if (s.kind != @@ident) then
				     SemErr(13)
				   end
				   p g
                                   Tab.CompleteGraph(g.r)
                                   DFA.ConvertToStates(g.l, sp)
				 .)
  |                             (. if (s.kind==@@ident) then
				     @@genScanner = false
                                   else
				     MatchLiteral(sp)
				   end
				.)
  )
  [ SemText <^pos>              (. if (typ==Tab::T) then
				     SemErr(14)
				   end
                                   Tab.Sym(sp).semPos = pos
				 .)
  ].
/*------------------------------------------------------------------------------------*/
AttrDecl <Sym sym>		(. beg = col = dim = 0
				   buf = nil
				 .)
=
  "<"
  [ "^"
    ident                       (. buf = @token.val.clone
    				   dim = 0
				 .)
    { "[" "]"			(. dim += 1 .)
    }
    ident                       (. sym.retVar = @token.val .)
    { "[" "]"			(. dim += 1 .)
    }				(. while (dim > 0) do
				     buf.append("[]")
				     dim -= 1
				   end
    				   sym.retType = buf.to_s
				 .)
    [","]
  ]                             (. beg = @t.pos
  				   col = @t.col
				 .)
  { ANY }
  ">"                           (. if (@token.pos > beg) then
                                     sym.attrPos = Position.new
                                     sym.attrPos.beg = beg
				     sym.attrPos.col = col
                                     sym.attrPos.len = @token.pos - beg
                                   end
				 .)
| "<."
  [ "^"
    ident                       (. buf = [ @token.val ]
    				   dim = 0
				 .)
    { "[" "]"			(. dim += 1 .)
    }
    ident                       (. sym.retVar = @token.val .)
    { "[" "]"			(. dim += 1 .)
    }				(. while (dim > 0) do
    				     buf << "[]"
				     dim -= 1
				   end
				   sym.retType = buf.join('')
				 .)
    [","]
  ]                             (. beg = @t.pos
  				   col = @t.col
				 .)
  { ANY }
  ".>"                          (. if (@token.pos > beg) then
                                       sym.attrPos = Position.new()
                                       sym.attrPos.beg = beg
				       sym.attrPos.col = col
                                       sym.attrPos.len = @token.pos - beg
                                   end
				 .).
/*------------------------------------------------------------------------------------*/
Expression <^Graph g>           (. g2 = nil
	   	   		   first = false
				 .)
=
  Term <^g>                     (. first = true .)
  { WEAK "|"
    Term <^g2>                  (. if (first) then
				     g = Tab.FirstAlt(g)
				     first = false
				   end
                                   g = Tab.Alternative(g, g2)
				 .)
  }.
/*------------------------------------------------------------------------------------*/
Term<^Graph g>                  (. g2 = nil .)
=                               (. g = nil .)
  ( Factor <^g>
    { Factor <^g2>              (. g = Tab.Sequence(g, g2) .)
    }
  |                             (. g = Graph.new()
                                   g.l = Tab.NewNode(Tab::Eps, 0, 0)
                                   g.r = g.l
				 .)
  ).
/*------------------------------------------------------------------------------------*/
Factor <^Graph g>               (. n = s = sym = pos = set = nil
				   sp = typ = 0
				   undefined = weak = false
				 .)
=
                                (. g = Graph.new()
				   weak = false
				 .)
( [ "WEAK"                      (. weak = true .)
  ]
  Symbol <^s>                   (. puts "symbol name = #{s.name}"
  	 			   sp = Tab.FindSym(s.name)
				   undefined = sp==Tab::NoSym
                                   if (undefined) then
                                       if (s.kind==@@ident) then
                                           sp = Tab.NewSym(Tab::Nt, s.name, 0) # forward nt
                                       elsif (@@genScanner) then
                                           sp = Tab.NewSym(Tab::T, s.name, @token.line)
                                           MatchLiteral(sp)
                                       else # undefined string in production
                                           SemErr(6) 
					   sp = 0
                                       end
                                   end
                                   sym = Tab.Sym(sp)
				   typ = sym.typ
                                   if (typ!=Tab::T && typ!=Tab::Nt) then
				     SemErr(4)
				   end
                                   if (weak) then
                                       if (sym.typ==Tab::T) then
				         typ = Tab::Wt
				       else
				         SemErr(23)
				       end
				   end
                                   g.l = Tab.NewNode(typ, sp, @token.line)
				   g.r = g.l
                                   n = Tab.Node(g.l)
				 .)
  [ Attribs <n>                 (. if (s.kind!=@@ident) then
    	    			     SemErr(3)
				   end
				 .)
  ]                             (. if (undefined) then
                                     sym.attrPos = n.pos
				     sym.retVar  = n.retVar # dummies
                                   else
                                     if ((!n.pos.nil?    &&  sym.attrPos.nil?) ||
				         (!n.retVar.nil? &&  sym.retVar.nil?) ||
					 ( n.pos.nil?    && !sym.attrPos.nil?) ||
					 ( n.retVar.nil? && !sym.retVar.nil?)) then
				       SemErr(5)
				     end
                                   end
				 .)
| "(" Expression <^g> ")"
| "[" Expression <^g> "]"       (. g = Tab.Option(g) .)
| "{" Expression <^g> "}"       (. g = Tab.Iteration(g) .)
| SemText <^pos>                (. g.l = Tab.NewNode(Tab::Sem, 0, 0)
                                   g.r = g.l
                                   n = Tab.Node(g.l)
				   n.pos = pos
				 .)
| "ANY"                         (. set = Sets.FullSet(Tab::MaxTerminals)
                                   set.clear(Tab::EofSy)
                                   g.l = Tab.NewNode(Tab::Any, Tab.NewSet(set), 0)
                                   g.r = g.l
				 .)
| "SYNC"                        (. g.l = Tab.NewNode(Tab::Sync, 0, 0)
                                   g.r = g.l
				 .)
).
/*------------------------------------------------------------------------------------*/
TokenExpr <^Graph g>            (. g2 = nil
				   first = false
				 .)
=
  TokenTerm <^g>                (. first = true .)
  { WEAK "|"
    TokenTerm <^g2>             (. if (first) then
				     g = Tab.FirstAlt(g)
				     first = false
				   end
                                   g = Tab.Alternative(g, g2)
				 .)
  }.
/*------------------------------------------------------------------------------------*/
TokenTerm <^Graph g>            (. g2 = nil .)
=
  TokenFactor <^g>
  { TokenFactor <^g2>           (. g = Tab.Sequence(g, g2) .)
  }
  [ "CONTEXT"
    "(" TokenExpr <^g2>         (. SetCtx(g2.l)
				   g = Tab.Sequence(g, g2)
				 .)
    ")"
  ].
/*------------------------------------------------------------------------------------*/
TokenFactor <^Graph g>          (. name = s = nil
				   kind = c = 0
				 .)
=
                                (. g = Graph.new .)
( Symbol <^s>                   (. if (s.kind==@@ident) then
                                     c = Tab.ClassWithName(s.name)
                                     if (c < 0) then
                                       SemErr(15)
                                       c = Tab.NewClass(s.name, BitSet.new())
                                     end
                                     g.l = Tab.NewNode(Tab::Clas, c, 0)
                                     g.r = g.l
                                   else # string
				     g = Tab.StrToGraph(s.name)
				   end
				.)
| "(" TokenExpr <^g> ")"
| "[" TokenExpr <^g> "]"        (. g = Tab.Option(g) .)
| "{" TokenExpr <^g> "}"        (. g = Tab.Iteration(g) .)
).
/*------------------------------------------------------------------------------------*/
Symbol <^SymInfo s> = 
                                (. s = SymInfo.new() .)
  ( ident                       (. s.kind = @@ident
				   s.name = @token.val
				 .)
  | string                      (. s.kind = @@string
				   s.name = FixString(@token.val)
				 .)
  ).
/*------------------------------------------------------------------------------------*/
Attribs <GraphNode n>           (. beg = col = 0 .)
= 
  "<"
  ( "^"                         (. beg = @t.pos .)
  	{ ANY }			(. n.retVar = ParserGen.GetString(beg, @t.pos)
				 .)
	( "," AttrRest<n>
	| ">"
	)
  |	AttrRest<n>
  )
| "<."                          /*alternative format to allow ">" in attributes*/
  ( "^"                         (. beg = @t.pos .)
  	{ ANY }			(. n.retVar = ParserGen.GetString(beg, @t.pos)
				 .)
	( "," AttrRest1<n>
	| ".>"
	)
  |	AttrRest1<n>
  ).
/*------------------------------------------------------------------------------------*/
AttrRest <GraphNode n>          (. beg = col = 0 .)
=
                                (. beg = @t.pos
				   col = @t.col
				 .)
  { ANY }
  ">"                           (. if (@token.pos > beg) then
                                     n.pos = Position.new()
                                     n.pos.beg = beg
				     n.pos.col = col
                                     n.pos.len = @token.pos - beg
                                   end
				.).
/*------------------------------------------------------------------------------------*/
AttrRest1 <GraphNode n>         (. beg = col = 0 .)
=
                                (. beg = @t.pos
				   col = @t.col
				 .)
  { ANY }
  ".>"                          (. if (@token.pos > beg) then
                                     n.pos = Position.new()
                                     n.pos.beg = beg
				     n.pos.col = col
                                     n.pos.len = @token.pos - beg
                                   end
				 .).
/*------------------------------------------------------------------------------------*/
SemText <^Position pos> = 
  "(."                          (. pos = Position.new()
                                   pos.beg = @t.pos
				   pos.col = @t.col
				 .)
  { ANY
  | badString                   (. SemErr(18) .)
  | "(."                        (. SemErr(19) .)
  }
  ".)"                          (. pos.len = @token.pos - pos.beg .).

END Coco.
